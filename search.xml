<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一名【合格】前端工程师的自检清单]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%87%AA%E6%A3%80%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 开篇前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。 winter在他的《重学前端》课程中提到： “到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习”。 这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个 API以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。 实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。 我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。 这不仅仅是我的知识体系，更是我时刻提醒自己的自检清单。 下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点。 一、JavaScript基础 前端工程师吃饭的家伙，深度、广度一样都不能差。 变量和类型 JavaScript规定了几种语言类型 JavaScript对象的底层数据结构是什么 Symbol类型在实际开发中的应用、可手动实现一个简单的 Symbol JavaScript中的变量在内存中的具体存储形式 基本类型对应的内置对象，以及他们之间的装箱拆箱操作 理解值类型和引用类型 null和 undefined的区别 至少可以说出三种判断 JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 出现小数精度丢失的原因， JavaScript可以存储的最大数字、最大安全数字， JavaScript处理大数字的方法、避免精度丢失的方法 原型和原型链 1.理解原型设计模式以及 JavaScript中的原型规则 2.instanceof的底层实现原理，手动实现一个 instanceof 3.实现继承的几种方式以及他们的优缺点 4.至少说出一种开源项目(如 Node)中应用原型继承的案例 5.可以描述 new一个对象的详细过程，手动实现一个 new操作符 6.理解 es6class构造以及继承的底层实现原理 作用域和闭包 1.理解词法作用域和动态作用域 2.理解 JavaScript的作用域和作用域链 3.理解 JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题 4.this的原理以及几种不同使用场景的取值 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 6.理解堆栈溢出和内存泄漏的原理，如何防止 7.如何处理循环的异步操作 8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理 执行机制 1.为何 try里面放 return， finally还会执行，理解其内部机制 2.JavaScript如何实现异步编程，可以详细描述 EventLoop机制 3.宏任务和微任务分别有哪些 4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 5.使用 Promise实现串行 6.Node与浏览器 EventLoop的差异 7.如何在保证页面运行流畅的情况下处理海量数据 语法和API 1.理解 ECMAScript和 JavaScript的关系 2.熟练运用 es5、 es6提供的语法规范， 3.熟练掌握 JavaScript提供的全局对象（例如 Date、 Math）、全局函数（例如 decodeURI、 isNaN）、全局属性（例如 Infinity、 undefined） 4.熟练应用 map、 reduce、 filter 等高阶函数解决问题 5.setInterval需要注意的点，使用 settimeout实现 setInterval 6.JavaScript提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL解析、去重等）解决常见问题 7.JavaScript异常处理的方式，统一的异常处理方案 二、HTML和CSSHTML 1.从规范的角度理解 HTML，从分类和语义的角度使用标签 2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式 3.元信息类标签( head、 title、 meta)的使用目的和配置方法 4.HTML5离线缓存原理 5.可以使用 CanvasAPI、 SVG等绘制高性能的动画 CSS 1.CSS盒模型，在不同浏览器的差异 2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用 at规则 3.CSS伪类和伪元素有哪些，它们的区别和实际应用 4.HTML文档流的排版规则， CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 5.水平垂直居中的方案、可以实现 6种以上并对比它们的优缺点 6.BFC实现原理，可以解决的问题，如何创建 BFC 7.可使用 CSS函数复用代码，实现特殊效果 8.PostCSS、 Sass、 Less的异同，以及使用配置，至少掌握一种 9.CSS模块化方案、如何配置按需加载、如何防止 CSS阻塞渲染 10.熟练使用 CSS实现常见动画，如渐变、移动、旋转、缩放等等 11.CSS浏览器兼容性写法，了解不同 API在不同浏览器下的兼容性情况 12.掌握一套完整的响应式布局方案 手写 1.手写图片瀑布流效果 2.使用 CSS绘制几何图形（圆形、三角形、扇形、菱形等） 3.使用纯 CSS实现曲线运动（贝塞尔曲线） 4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点 三、计算机基础 关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要 编译原理 1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 2.正则表达式的匹配原理和性能优化 3.如何将 JavaScript代码解析成抽象语法树( AST) 4.base64的编码原理 5.几种进制的相互转换计算方法，在 JavaScript中如何表示和转换 网络协议 1.理解什么是协议，了解 TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用 2.三次握手和四次挥手详细原理，为什么要使用这种机制 3.有哪些协议是可靠， TCP有哪些手段保证可靠交付 4.DNS的作用、 DNS解析的详细过程， DNS优化原理 5.CDN的作用和原理 6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题 8.HTTP1.1、 HTTP2.0带来的改变 9.HTTPS的加密原理，如何开启 HTTPS，如何劫持 HTTPS请求 10.理解 WebSocket协议的底层原理、与 HTTP的区别 设计模式 1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 2.发布订阅模式和观察者模式的异同以及实际应用 3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用 四、数据结构和算法 据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ JavaScript编码能力 1.多种方式实现数组去重、扁平化、对比优缺点 2.多种方式实现深拷贝、对比优缺点 3.手写函数柯里化工具函数、并理解其应用场景和优势 4.手写防抖和节流工具函数、并理解其内部原理和应用场景 5.实现一个 sleep函数 手动实现前端轮子 1.手动实现 call、apply、bind 2.手动实现符合 Promise/A+规范的 Promise、手动实现 asyncawait 3.手写一个 EventEmitter实现事件发布、订阅 4.可以说出两种实现双向绑定的方案、可以手动实现 5.手写 JSON.stringify、 JSON.parse 6.手写一个模版引擎，并能解释其中原理 7.手写 懒加载、 下拉刷新、 上拉加载、 预加载等效果 数据结构 1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 2.理解 数组、 字符串的存储原理，并熟练应用他们解决问题 3.理解 二叉树、 栈、 队列、 哈希表的基本结构和特点，并可以应用它解决问题 4.了解 图、 堆的基本结构和使用场景 算法 1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 4.可应用 回溯算法、 贪心算法、 分治算法、 动态规划等解决复杂问题 5.前端处理海量数据的算法方案 五、运行环境我们需要理清语言和环境的关系 ECMAScript描述了 JavaScript语言的语法和基本对象规范浏览器作为 JavaScript的一种运行环境，为它提供了：文档对象模型（ DOM），描述处理网页内容的方法和接口、浏览器对象模型（ BOM），描述与浏览器进行交互的方法和接口,Node也是 JavaScript的一种运行环境，为它提供了操作 I/O、网络等 API 浏览器API 1.浏览器提供的符合 W3C标准的 DOM操作 API、浏览器差异、兼容性 2.浏览器提供的浏览器对象模型 ( BOM)提供的所有全局 API、浏览器差异、兼容性 3.大量 DOM操作、海量数据的性能优化(合并操作、 Diff、 requestAnimationFrame等) 4.浏览器海量数据存储、操作性能优化 5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理 6.前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、 fetch、可以熟练使用第三方库 7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 8.浏览器提供的几种存储机制、优缺点、开发中正确的选择 9.浏览器跨标签通信 浏览器原理 1.各浏览器使用的 JavaScript引擎以及它们的异同点、如何在代码中进行区分 2.请求数据到请求结束与服务器进行了几次交互 3.可详细描述浏览器从输入 URL到页面展现的详细过程 4.浏览器解析 HTML代码的原理，以及构建 DOM树的流程 5.浏览器如何解析 CSS规则，并将其应用到 DOM树上 6.浏览器如何将解析好的带有样式的 DOM树进行绘制 7.浏览器的运行机制，如何配置资源异步同步加载 8.浏览器回流与重绘的底层原理，引发原因，如何有效避免 9.浏览器的垃圾回收机制，如何避免内存泄漏 10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案 node 1.理解 Node在应用程序中的作用，可以使用 Node搭建前端运行环境、使用 Node操作文件、操作数据库等等 2.掌握一种 Node开发框架，如 Express， Express和 Koa的区别 3.熟练使用 Node提供的 API如 Path、 Http、 ChildProcess等并理解其实现原理 4.Node的底层运行原理、和浏览器的异同 5.Node事件驱动、非阻塞机制的实现原理 六、框架和类库 轮子层出不穷，从原理上理解才是正道 TypeScript 1.理解 泛型、 接口等面向对象的相关概念， TypeScript对面向对象理念的实现 2.理解使用 TypeScript的好处，掌握 TypeScript基础语法 3.TypeScript的规则检测原理 4.可以在 React、 Vue等框架中使用 TypeScript进行开发 React 1.React和 vue选型和优缺点、核心架构的区别 2.React中 setState的执行机制，如何有效的管理状态 3.React的事件底层实现机制 4.React的虚拟 DOM和 Diff算法的内部实现 5.React的 Fiber工作原理，解决了什么问题 6.ReactRouter和 VueRouter的底层实现原理、动态加载实现原理 7.可熟练应用 ReactAPI、生命周期等，可应用 HOC、 render props、 Hooks等高阶用法解决问题 8.基于 React的特性和原理，可以手动实现一个简单的 React Vue 1.熟练使用 Vue的 API、生命周期、钩子函数 2.MVVM框架设计理念 3.Vue双向绑定实现原理、 Diff算法的内部实现 4.Vue的事件机制 5.从 template转换成真实 DOM的实现机制 多端开发 1.单页面应用（ SPA）的原理和优缺点，掌握一种快速开发 SPA的方案 2.理解 Viewport、 em、 rem的原理和用法，分辨率、 px、 ppi、 dpi、 dp的区别和实际应用 3.移动端页面适配解决方案、不同机型适配方案 4.掌握一种 JavaScript移动客户端开发技术，如 ReactNative：可以搭建 ReactNative开发环境，熟练进行开发，可理解 ReactNative的运作原理，不同端适配 5.掌握一种 JavaScript PC客户端开发技术，如 Electron：可搭建 Electron开发环境，熟练进行开发，可理解 Electron的运作原理 6.掌握一种小程序开发框架或原生小程序开发 7.理解多端框架的内部实现原理，至少了解一个多端框架的使用 数据流管理 1.掌握 React和 Vue传统的跨组件通信方案，对比采用数据流管理框架的异同 2.熟练使用 Redux管理数据流，并理解其实现原理，中间件实现原理 3.熟练使用 Mobx管理数据流，并理解其实现原理，相比 Redux有什么优势 4.熟练使用 Vuex管理数据流，并理解其实现原理 5.以上数据流方案的异同和优缺点，不情况下的技术选型 实用库 1.至少掌握一种 UI组件框架，如 antd design，理解其设计理念、底层实现 2.掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表 3.掌握一种 GIS开发框架，如百度地图 API 4.掌握一种可视化开发框架，如 Three.js、 D3 5.工具函数库，如 lodash、 underscore、 moment等，理解使用的工具类或工具函数的具体实现原理 开发和调试 1.熟练使用各浏览器提供的调试工具 2.熟练使用一种代理工具实现请求代理、抓包，如 charls 3.可以使用 Android、 IOS模拟器进行调试，并掌握一种真机调试方案 4.了解 Vue、 React等框架调试工具的使用 七、前端工程 前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度 项目构建 1.理解 npm、 yarn依赖包管理的原理，两者的区别 2.可以使用 npm运行自定义脚本 3.理解 Babel、 ESLint、 webpack等工具在项目中承担的作用 4.ESLint规则检测原理，常用的 ESLint配置 5.Babel的核心原理，可以自己编写一个 Babel插件 6.可以配置一种前端代码兼容方案，如 Polyfill 7.Webpack的编译原理、构建流程、热更新原理， chunk、 bundle和 module的区别和应用 8.可熟练配置已有的 loaders和 plugins解决问题，可以自己编写 loaders和 plugins nginx 1.正向代理与反向代理的特点和实例 2.可手动搭建一个简单的 nginx服务器、 3.熟练应用常用的 nginx内置变量，掌握常用的匹配规则写法 4.可以用 nginx实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理 开发提速 1.熟练掌握一种接口管理、接口 mock工具的使用，如 yapi 2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题 3.理解 TDD与 BDD模式，至少会使用一种前端单元测试框架 版本控制 1.理解 Git的核心原理、工作流程、和 SVN的区别 2.熟练使用常规的 Git命令、 git rebase、 git stash等进阶命令 3.可以快速解决 线上分支回滚、 线上分支错误合并等复杂问题 持续集成 1.理解 CI/CD技术的意义，至少熟练掌握一种 CI/CD工具的使用，如 Jenkins 2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web应用、移动客户端应用、 PC客户端应用、小程序、 H5等等） 八、项目和业务后端技能 1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言 2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库 性能优化 1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案 2.了解常见的 Web、 App性能优化方案 3.SEO排名规则、 SEO优化方案、前后端分离的 SEO 4.SSR实现方案、优缺点、及其性能优化 5.Webpack的性能优化方案 6.Canvas性能优化方案 7.React、 Vue等框架使用性能优化方案 前端安全 1.XSS攻击的原理、分类、具体案例，前端如何防御 2.CSRF攻击的原理、具体案例，前端如何防御 3.HTTP劫持、页面劫持的原理、防御措施 业务相关 1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题 2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题 3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性 九、技术之外 这部分可能比上面九条加起来重要！ 1.了解互联网人员术语： CEO、 CTO、 COO、 CFO、 PM、 QA、 UI、 FE、 DEV、 DBA、 OPS等 2.了解互联网行业术语： B2B、 B2C、 C2C、 O2O等 3.掌握互联网行业沟通、问答、学习的 4.有一定的 “PPT”能力 5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识 6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系 十、资源推荐有了知识体系，在阅读一篇技术文章的时候就很容易把它归类，我一直以来就是这样做的。事实证明，在阅读文章或书籍时，有目的和归类的阅读比”随便看看”后的只是留存率要高很多。每阅读到一篇好的文章或者书籍，我都会收藏并归类到我的知识体系中。 下面是一些我觉得还不错的文章、博客或者书籍教程等等，分享给大家，资源不多，但都是精品。学习一门知识，最好先阅读官方文档，把所有的 API大概浏览一遍，再继续看大佬们总结的进阶知识，什么东西是搬运过来的，什么是干货，一目了然。 语言基础 JavaScript高级程序设计：https://book.douban.com/subject/10546125/ 高性能 JavaScript：https://book.douban.com/subject/5362856/ 现代 JavaScript教程：https://zh.javascript.info/ 阮一峰的 ECMAScript6教程：http://es6.ruanyifeng.com/ ECMAScript6标准：https://www.ecma-international.org/ecma-262/6.0/ HTML meta标签总结与属性使用介绍：https://segmentfault.com/a/1190000004279791 CSS编码指导：https://github.com/chadluo/CSS-Guidelines/blob/master/README.md 计算机基础 大前端开发者需要了解的基础编译原理和语言知识：http://fullstack.blog/2017/06/24/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86 图解 HTTP：https://book.douban.com/subject/25863515/ JavaScript设计模式与开发实践：https://book.douban.com/subject/26382780/ 正则表达式30分钟入门教程：https://link.juejin.im/?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm 数据结构和算法 数据结构与算法之美：https://time.geekbang.org/column/intro/126 用动画的形式呈现解LeetCode题目的思路：https://github.com/MisterBooo/LeetCodeAnimation JavaScript数据结构和算法：https://github.com/ConardLi/awesome-coding-js 30-seconds-of-code：https://github.com/ConardLi/30-seconds-of-code-Zh-CN 运行环境 图解浏览器的基本工作原理：https://zhuanlan.zhihu.com/p/47407398 七天学会 NodeJS：https://github.com/nqdeng/7-days-nodejs Node.js模块加载与运行原理：https://efe.baidu.com/blog/nodejs-module-analyze/ 框架和类库 图解浏览器的基本工作原理：https://zhuanlan.zhihu.com/p/47407398 七天学会 NodeJS：https://github.com/nqdeng/7-days-nodejs Node.js模块加载与运行原理：https://efe.baidu.com/blog/nodejs-module-analyze/ 前端工程 一口（很长的）气了解 babel：https://zhuanlan.zhihu.com/p/43249121 Webpack傻瓜式指南：https://zhuanlan.zhihu.com/p/20367175 Webpack原理：https://segmentfault.com/a/1190000015088834?utm_source=tag-newest 廖雪峰git教程：https://www.liaoxuefeng.com/wiki0013739516305929606dd18361248578c67b8067c8c017b000 图解 Git：https://marklodato.github.io/visual-git-guide/index-zh-cn.html 必备Nginx知识：https://juejin.im/post/5c85a64d6fb9a04a0e2e038c 使用Jenkins进行持续集成：https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000 项目和业务 常见六大 Web安全攻防解析：https://github.com/ljianshu/Blog/issues/56 深入理解前端性能监控：https://juejin.im/post/5caaacc0e51d452b45296487#heading-5 [📚]高性能网站建设指南：https://book.douban.com/subject/3132277/ 新人如何快速融入技术实力强的前端团队：https://juejin.im/post/5cb860a86fb9a06890705f14 学习提升 印记中文（各种中文开发文档）：https://www.docschina.org/ 前端学习方法：https://github.com/helloqingfeng/Awsome-Front-End-learning-resource/tree/master/01-FE-learning-master 如何在工作内外获得持续的技术成长：https://juejin.im/post/5cbd7477f265da039d32834e 优秀的前端博客汇总：https://github.com/foru17/front-end-collect 另外推荐几位大佬的个人博客： 冴羽的博客：https://github.com/mqyqingfeng/Blog 张鑫旭的博客：https://www.zhangxinxu.com/wordpress/ 左耳朵耗子：https://coolshell.cn/ 技术之外 互联网术语大全：https://www.jianshu.com/p/9a7ca206c1ab 互联网沟通、问答、学习的艺术：https://zhuanlan.zhihu.com/p/41431775 经常加班至深夜，怎样才能保持身体健康：https://www.zhihu.com/question/21790919 其实在这个信息发达的时代最不缺的就是资源，如何从众多的资源中获取到真正精华的部分，是非常重要的，资源在于精不在于多，强烈建议在保证深度的情况下再保证广度。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔 - 如何用es6+写出优雅的js代码]]></title>
    <url>%2F2018%2F12%2F12%2F%E9%9A%8F%E7%AC%94-%E5%A6%82%E4%BD%95%E7%94%A8es6%2B%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84js%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 好处就是：解决了访问多层嵌套的对象或数组的命名，减少代码量 声明多个变量: 12let [age, name, sex] = [22, 'guodada', 1]console.log(age, name, sex) // 22, guodada, 1 使用在对象中： 123456789101112const obj = &#123; name: &#123; firstName: 'guo', lastName: 'dada' &#125;&#125;// 如果我们多处使用 firstName， 那就不必要每个地方都写 obj.name.firstName, 这样极大提升coding效率const &#123; firstName, lastName &#125; = obj.name// 等同于const firstName = obj.name.firstNameconst lastName = obj.name.lastName 使用在函数中: 1234567// 在参数中结构赋值，获取参数, 当参数多的使用时候十分方便function Destructuring(&#123; name, age &#125;) &#123; return &#123; name, age &#125; // 相当于 &#123; name: name, age: age &#125; , 可以简写&#125;const params = &#123; name: 'guodada', age: 22 &#125;Destructuring(params) 更多用法见 变量的解构赋值 ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 12345678910function f(x, y) &#123; return &#123; x, y &#125;&#125;// 等同于function f(x, y) &#123; return &#123; x: x, y: y &#125;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 扩展符的运用es6 扩展符有很多用法，他可以使你的代码更加简洁，易懂。这里就举例常用的用法 在对象中的用法： 123456789101112131415let obj = &#123; name: 'guodada', age: 22, sex: 1&#125;// 复制对象。扩展符为浅复制！！！const copy = &#123; ...obj &#125;// 修改对象属性值(生成新对象) 相当于 Object.assgin(&#123;&#125;, obj, &#123; age: 18 &#125;)const newObj = &#123; ...obj, age: 18 &#125;// 结合结构赋值let &#123; sex, ...z &#125; = objz // &#123; name: 'guodada', age: 22 &#125; 在数组中的用法： 1234567891011121314const arr = [1, 2, 3]const arr2 = [4, 5, 6, 4]// 复制数组。扩展符为浅复制！！！const newArr = [...arr] // ...[1, 2, 3] =&gt; 相当于展开数组：1, 2, 3// 合并数组const conbineArr = [...arr, ...arr2]// 结合求最大值函数Math.max(...arr)// 结合 Set 实现数组去重。注意：json 等对象数组不可用[...new Set(arr2)] // [4, 5, 6] 扩展符的其他用法请自行查资料。 数组用法1234567891011121314const arr = [1, 2, 3, 4]Array.isArray(arr) // 判断是否为数组arr.includes(2) // true 判断数组中是否包含某项arr.findIndex(d =&gt; d === 3) // 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1arr.find(d =&gt; d === 3) // 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined// es5 其他还有 filter map forEach 等，这里不做举例。arr.every(d =&gt; d &gt; 2) // false 每一项都满足条件则返回 truearr.some(d =&gt; d &gt; 2) // true 只要有一项满足条件则返回 true find/findIndex : 找出第一个符合条件的数组成员之后不再匹配，一定程度下优化查找。includes: 返回 true/false, 相较于 indexOf, 实用多了 flat() : 扁平化数组，常用于将数组转化为一维数组 12345678const arr = [1, 2, [3, 4]]arr.flat() // [1, 2, 3, 4] 扁平化数组, 默认展开一层。const arr2 = [1, 2, [3, 4, [5, 6]]]arr2.flat() // [1, 2, 3, 4, [5, 6]]arr2.flat(2) // [1, 2, 3, 4, 5, 6] flat(3) 也是展开两层... flatMap(): 在数组执行 map 方法后执行 flat, 用的不多，其实可以写 map 后写 flat 更好懂点。 123;[2, 3, 4].flatMap(x =&gt; [x, x * 2]) // [ 2, 4, 3, 6, 4, 8 ]// 1. [2, 3, 4].map(d =&gt; [d, d * 2]) =&gt; [[2, 4], [3, 6], [4, 8]]// 2. [[2, 4], [3, 6], [4, 8]].flat() 补充常用的对象转数组的用法： 12345const obj = &#123; name: 'guodada' &#125;Object.keys(obj) // ['name']Object.values(obj) // ['guodada']Object.entries(obj) // [['name', 'guodada']] 模板字符串用的挺多的，注意不兼容 IE ! 123456const name = 'guodada'const newStr = `welcome $&#123;name&#125;` // welcome guodada// the same asconst newStr = 'welcome ' + name 使用 async / awaitasync/await 实际上就是 generator 的语法糖, 主要用来解决异步问题，具体网上很多文章都有介绍，这里就不做多的解释吧。 123456789101112131415161718async function test() &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data)&#125;// 等同于function test() &#123; axios.get('https://randomuser.me/api/').then(res =&gt; console.log(res)) // axios 也是 promise 对象&#125;// 结合try/catchasync function test() &#123; try &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data) &#125; catch (err) &#123; console.log(err) &#125;&#125; ps 虽然好用，但是有时候适用场景不好，比如我们在拉取列表和用户信息需要同时进行时，await 后才执行下一条语句，这不是我们希望看到的。解决方法如下： 12// 结合 Promise.allawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) 传送门：async 函数 利用 class 封装代码主要是抽离代码逻辑，使得代复用性加强。同时，class 的形式会让结构变得更加清晰，譬如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyForm &#123; /** * @func defaultLimit - 默认表单输入限制条件, value 为空时返回 true * @param &#123;Number&#125; type - 代表表单类型的节点！ * @param &#123;String&#125; value - 需要被验证的值 * @return Boolean * * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 * 4 0≤x≤10 */ static defaultLimit(type, value) &#123; const typeLimitMap = &#123; 1: /^(\d|[1-4]\d|50)$/g, 2: /^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/, 3: /^[1-9]\d*$/, 4: value =&gt; value &lt;= 10 &amp;&amp; value &gt;= 0 // 0≤ x ≤ 10 可以为小数 &#125; if (!typeLimitMap[type] || !value) return true if (typeof typeLimitMap[type] === 'function') return typeLimitMap[type](value) else return typeLimitMap[type].test(value) &#125; /** * @func translateLimit - 转换操作符 * @param &#123;String&#125; operator - 运算符 * @param &#123;*&#125; value - 被匹配的值 * @param &#123;*&#125; compareValue - 匹配的值 * @return Boolean * 'eq': '=' * 'ne': '≠' * 'gt': '&gt;' * 'lt': '&lt;' * 'ge': '≥' * 'le': '≤' */ static translateLimit(operator, value, compareValue) &#123; const type = &#123; eq: value === compareValue, ne: value !== compareValue, gt: value &gt; compareValue, lt: value &lt; compareValue, ge: value &gt;= compareValue, le: value &lt;= compareValue &#125; if (!Object.keys(type).includes(operator) || !value || value === '-') return true return type[operator] &#125; // ...&#125;export default MyForm 使用： 123import MyForm from './MyForm'MyForm.defaultLimit(1, 20) static ：静态属性，类可以直接调用 constructor : 实例化类的时候调用，即 new MyForm(), 这里没用到 更多知识请阅 Class 的基本语法 优化 if/else 语句 当逻辑或||时，找到为 true 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。 当逻辑与&amp;&amp;时，找到为 false 的分项就停止处理，并返回该分项的值。 12345const a = 0 || null || 3 || 4console.log(a) // 3const b = 3 &amp;&amp; 4 &amp;&amp; null &amp;&amp; 0console.log(b) // null 减少 if / else地狱般的调用 1234567891011121314151617const [age, name, sex] = [22, 'guodada', 1]if (age &gt; 10) &#123; if (name === 'guodada') &#123; if (sex &gt; 0) &#123; console.log('all right') &#125; &#125;&#125;// 使用 &amp;&amp;if (age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0) &#123; console.log('all right')&#125;// 或者(太长了不推荐)age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0 &amp;&amp; console.log('all right') 提一下 react 的坑点, 在 render 中 12345678910render()&#123; const arr = [] return arr.length &amp;&amp; null&#125;// 渲染出 0 ！// Boolean / undefind / null / NaN 等才不会渲染。我们可以使用 !! 强制转化为 boolean 解决这个问题return !!arr.length &amp;&amp; null// 使用 &amp;&amp; 控制组件的渲染this.state.visible &amp;&amp; &lt;Modal /&gt; 使用 Array.includes 来处理多重条件： 12345678910const ages = [18, 20, 12]if (age === 18 || age === 12) &#123; console.log('match')&#125;// betterif ([18, 12].includes(age)) &#123; console.log('match')&#125; 如果是较少的判断逻辑则可以使用三元运算符： 1234const age = 22const isAdult = age &gt;= 18 ? true : false // 这里可以简写为 const isAdult = age &gt; 18const type = age &gt;= 18 ? 'adult' : 'child' 优化 switch/case 语句switch/case 比 if/else 代码结构好点，但也和它一样有时十分冗长。 这里以自己实际项目中代码举例：有时我们可能需要对不同类型的字段进行不一样的正则验证，防止用户错误地输入。譬如 12345678910111213141516171819202122232425262728293031323334353637const [type, value] = [1, '20']/** * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 */function func1(type, value) &#123; if (type === 1) &#123; return /^(\d|[1-4]\d|50)$/.test(value) &#125; else if (type === 2) &#123; return /^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/.test(value) &#125; else if (type === 3) &#123; return /^[1-9]\d*$/.test(value) &#125; else &#123; return true &#125;&#125;func1(type, value)// 使用 switch/casefunction fun2(type, value) &#123; switch (type) &#123; case 1: return /^(\d|[1-4]\d|50)$/.test(value) case 2: return /^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/.test(value) case 3: return /^[1-9]\d*$/.test(value) default: return true &#125;&#125;func2(type, value) 我们如何巧妙的解决这个代码冗长的问题呢，如下： 12345678function func3(type, value) &#123; const limitMap = &#123; 1: /^(\d|[1-4]\d|50)$/g, 2: /^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/, 3: /^[1-9]\d*$/ &#125; return limitMap[type].test(value)&#125; 利用对象去匹配属性值，可以减少你的代码量，也使你的代码看起来更加简洁。你也可以使用 Map 对象去匹配。 12345function func4(type, value) &#123; const mapArr = [[1, /^(\d|[1-4]\d|50)$/g], [2, /^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/], [3, /^[1-9]\d*$/]] const limitMap = new Map(mapArr) return limitMap.get(type).test(value)&#125; Map 是一种键值对的数据结构对象，它的匹配更加严格。它会区分开你传递的是字符串还是数字，譬如： 12limitMap.get(1) // /^(\d|[1-4]\d|50)$/glimitMap.get('1') // undefined 更多详见 Set 和 Map 数据结构 其他 函数参数默认值 12345function func(name, age = 22) &#123;&#125;// 等同于function func(name, age) &#123; age = age || 22&#125; 使用 === 代替 ==。其实大家都懂这个的。。。 箭头函数，es6 最常用的语法。 return boolean1234const a = 1return a === 1 ? true : false// 多此一举了，其实就等于return a === 1 敬请各位补充。交流才能进步，相视一笑，嘿嘿。 github - star 一下人生更美好 blog - 欢迎交流]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP - keep-alive]]></title>
    <url>%2F2018%2F11%2F23%2Fhttp-%E9%95%BF%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[HTTP 协议是无状态的HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。 什么是长连接、短连接？在 HTTP/1.0 中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次 HTTP 操作，就要经过三次握手建立一次连接，但任务结束就中断连接。 客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源，如 JavaScript 文件、图像文件、CSS 文件等；当浏览器每遇到这样一个 Web 资源，就会建立一个 HTTP 会话。但从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头有加入这行代码： 1'Connection': 'keep-alive' 实战 test.html 123456789101112&lt;body&gt; &lt;img src="/test1.jpg" alt="" /&gt; &lt;img src="/test2.jpg" alt="" /&gt; &lt;img src="/test3.jpg" alt="" /&gt; &lt;img src="/test4.jpg" alt="" /&gt; &lt;img src="/test5.jpg" alt="" /&gt; &lt;img src="/test6.jpg" alt="" /&gt; &lt;img src="/test7.jpg" alt="" /&gt; &lt;img src="/test11.jpg" alt="" /&gt; &lt;img src="/test12.jpg" alt="" /&gt; &lt;img src="/test13.jpg" alt="" /&gt; &lt;img src="/test14.jpg" alt="" /&gt; &lt;img src="/test15.jpg" alt="" /&gt; &lt;img src="/test16.jpg" alt="" /&gt; &lt;img src="/test17.jpg" alt="" /&gt; &lt;img src="/test111.jpg" alt="" /&gt; &lt;img src="/test112.jpg" alt="" /&gt; &lt;img src="/test113.jpg" alt="" /&gt; &lt;img src="/test114.jpg" alt="" /&gt; &lt;img src="/test115.jpg" alt="" /&gt; &lt;img src="/test116.jpg" alt="" /&gt;&lt;/body&gt; server.js 12345678910111213141516171819202122232425const http = require('http')const fs = require('fs')http .createServer(function(request, response) &#123; console.log('request come', request.url) const html = fs.readFileSync('test.html', 'utf8') const img = fs.readFileSync('test.jpg') if (request.url === '/') &#123; response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;) response.end(html) &#125; else &#123; response.writeHead(200, &#123; 'Content-Type': 'image/jpg', Connection: 'keep-alive' // or close HTTP/1.1 起 默认 keep-alive &#125;) response.end(img) &#125; &#125;) .listen(8888)console.log('server listening on 8888')]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP - 跨域]]></title>
    <url>%2F2018%2F11%2F22%2Fhttp-%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是跨域 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。 我们可以简单的重现浏览器的跨域问题： server.js 模拟客户端： 12345678910111213const http = require('http')const fs = require('fs')http .createServer(function(request, response) &#123; console.log('request come', request.url) const html = fs.readFileSync('demo.html', 'utf8') response.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;) response.end(html) &#125;) .listen(3300) // http://127.0.0.1:3300 demo.html 展示的页面： 12345678&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.open('GET', 'http://127.0.0.1:6060') xhr.send() &lt;/script&gt;&lt;/body&gt; server2.js 模拟服务端： 12345678910const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.end('server2 response') &#125;) .listen(6060)console.log('server listening on 6060') 打开 http://127.0.0.1:3300 即可看到 Access to XMLHttpRequest at ‘http://127.0.0.1:6060/‘ from origin ‘http://127.0.0.1:3300‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 后续将讲到如何去解决这个问题。 常见的跨域场景 所谓的同源是指，域名、协议、端口均为相同。 1234567891011121314151617181920URL 说明 是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js 同一域名，不同文件或路径 允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js 同一域名，不同端口 不允许http://www.domain.com/a.jshttps://www.domain.com/b.js 同一域名，不同协议 不允许http://www.domain.com/a.jshttp://192.168.4.12/b.js 域名和域名对应相同ip 不允许http://www.domain.com/a.jshttp://x.domain.com/b.js 主域相同，子域不同 不允许http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js 不同域名 不允许 跨域的解决方法如下 JSONP HTML 标签里，一些标签比如 script、img 这样的获取资源的标签是没有跨域限制的 jsonp 原生的实现方式（以前面的代码为例） demo.html 123456789101112&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; // 1. 动态创建 script，并引入地址；2. 插入html中；3.通过callback 回调得到数据 let script = document.createElement('script') script.src = 'http://127.0.0.1:6060/login?username=guodada&amp;callback=onBack' document.body.appendChild(script) function onBack(res) &#123; console.log(res) &#125; &lt;/script&gt;&lt;/body&gt; server2.js 服务端： 1234567891011121314151617const http = require('http')const url = require('url')http .createServer(function(request, response) &#123; console.log('request come', request.url) const data = &#123; name: 'guodada' &#125; // 需要传递的数据 const &#123; callback &#125; = url.parse(request.url, true).query // 处理 get 请求, 拿到callback response.writeHead(200, &#123; 'Content-Type': 'application/json;charset=utf-8' &#125;) const jsonpCallback = callback + `($&#123;JSON.stringify(data)&#125;)` // 相当于 onBack(&#123;"name":"guodada"&#125;) response.end(jsonpCallback) &#125;) .listen(6060)console.log('server listening on 6060') 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现 get 请求 CORS简介因为是目前主流的跨域解决方案。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。IE8+：IE8/9 需要使用 XDomainRequest 对象来支持 CORS。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。 请求方式为 HEAD、POST 或者 GET HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。 下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个 Origin 字段。 server2.js 1234567891011121314151617const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.writeHead(200, &#123; 'Access-Control-Allow-Origin': 'http://127.0.0.1:3300', // 只有 http://127.0.0.1:3300 才能访问 'Access-Control-Allow-Credentials': true, // 允许携带 cookie 'Content-Type': 'text/html; charset=utf-8' &#125;) response.end('hello cors') &#125;) .listen(6060)console.log('server listening on 6060') demo.html 1234567891011&lt;body&gt; &lt;div&gt;demo.html&lt;/div&gt; &lt;script&gt; const xhr = new XMLHttpRequest() xhr.withCredentials = true // server: 'Access-Control-Allow-Credentials': true xhr.open('GET', 'http://127.0.0.1:6060') xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') xhr.send() &lt;/script&gt;&lt;/body&gt; Access-Control-Allow-Origin : 该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个*，表示接受任意域名的请求 Access-Control-Allow-Credentials: 表示是否允许发送 Cookie Access-Control-Expose-Headers: CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。 withCredentials 属性上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials 字段。 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略 withCredentials 设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials。 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 demo.html 1234567// 部分代码const xhr = new XMLHttpRequest()xhr.withCredentials = true // 允许携带 cookiexhr.open('PUT', 'http://127.0.0.1:6060') // 使用 put 请求，server：'Access-Control-Request-Method': 'PUT'xhr.setRequestHeader('X-Test-Cors', '123') // 设置预检头xhr.send() server2.js 1234567891011121314151617const http = require('http')http .createServer(function(request, response) &#123; response.writeHead(200, &#123; 'Access-Control-Allow-Origin': 'http://127.0.0.1:3300', // 只有 http://127.0.0.1:3300 才能访问 'Access-Control-Allow-Credentials': true, // 允许携带 cookie 'Access-Control-Allow-Headers': 'X-Test-Cors', // 预检 'Access-Control-Allow-Methods': 'POST, PUT, DELETE', // 支持 'Access-Control-Max-Age': '1000' // 指定本次预检请求的有效期，单位为秒 &#125;) response.end('hello cors') &#125;) .listen(6060)console.log('server listening on 6060') Access-Control-Allow-Methods: 返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers: 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。 Access-Control-Max-Age: 用来指定本次预检请求的有效期，单位为秒。 CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 postMessage…. 略 window.name + iframe…. 略 参考 正确面对跨域，别慌]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP - 导学]]></title>
    <url>%2F2018%2F11%2F20%2Fhttp-%E5%AF%BC%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[经典五层网络模型 在每一台电脑，每个服务器都有这这几个网络模型层级来维护整个网络数据传输过程。 一张图了解 TCP/IP 五层网络模型 物理层：将信息编码成电流脉冲或其它信号用于网上传输；（电线、光缆等） 数据链路层：数据链路层通过物理网络链路供数据传输。可以简单的理解为：规定了 0 和 1 的分包形式，确定了网络数据包的形式。 网络层：网络层负责在源和终点之间建立连接;（路由器等） 传输层： 敲重点！ 传输层向用户提供可靠的端对端(End-to-End)服务。 常用的（TCP／IP）协议 、UDP 协议； 应用层：敲重点！ 为应用软件提供了很多服务，帮我们实现了 HTTP 协议，我们只要按照规则去使用 HTTP 协议；它构建于 TCP 协议之上；屏蔽了网络传输相关细节。 重点在 应用层 和 传输层 上：http 是在应用层上去实现的，而 http 协议基于传输层的 TCP UDP 协议。 HTTP 发展历史HTTP/0.9 HTTP/0.9 只支持一种方法—— Get，请求只有一行 没有 header 等描述数据的信息 服务器发送完毕，就关闭 TCP 连接 HTTP/1.0 请求与响应支持 header，增加了状态码，响应对象的一开始是一个响应状态行 协议版本信息需要随着请求一起发送，支持 HEAD，POST 方法 HTTP/1.1在 HTTP/1.0 上增加了一些功能来优化网络链接的过程： 持久连接 HTTP/1.0 版本里一个 HTTP 请求就要在客户端和服务端之间创建一次 TCP 连接，在服务器返回完内容后就关闭了。相对来说消耗比较高。 pipeline 我们可以在同个连接里发送多个请求，但是服务端要对这些请求都是要按照顺序进行内容的返回。前一个请求等待时间较长，后一个请求处理较快，后一个请求也不能进行内容响应，需要等前一个请求完成后才可响应下次请求，这也是串行/并行的概念，而这个在 HTTP/2.0 中做了优化 host 和其他一些命令 有了 host 之后可以在同一台服务器（物理服务器）同时跑多个不同的 web 服务 ，比如说 node.js 的服务、java 的服务。 引入更多缓存控制机制：如 etag，cache-control … HTTP/2.0 使用二进制分帧层 在 HTTP/1.1 中大部分的数据传输都是以字符串方式进行的，HTTP/2.0 则在应用层与传输层之间增加一个二进制分帧层。同样因为这个好处，pipeline 在同个连接里发送多个请求不再需要按照顺序来返回处理。 头部压缩 头信息压缩：在 HTTP/1.1 里面，我们每次发送和返回请求 http header 都是必须要进行完整的发送和返回的，占用带宽。使用首部表来跟踪和存储之前发送的键值对，对于相同的内容，不会再每次请求和响应时发送。 服务端推送 在 HTTP/2.0 中，服务器可以向客户发送请求之外的内容，比如正在请求一个页面时，服务器会把页面相关的 logo，CSS 等文件直接推送到客户端，而不会等到请求来的时候再发送，因为服务器认为客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源。 … HTTP 的三次握手http-tcp 的三次握手四次挥手 URI-URL 和 URN URI : Uniform Resource Identifier/统一资源标志符 URL 和 URN 都是 URI 的子集 统一资源标识符（URI）提供了一个简单、可扩展的资源标识方式。 URL : Uniform Resource Locator/统一资源定位器 URL 是 Internet 上用来描述信息资源的字符串，主要用在各种 WWW 客户程序和服务器程序上。 采用 URL 可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。123456;`http://user:pass@host.com:80/path?query=string#hash` // @example url 的组成/** * http:// ===&gt; 协议，类似的还有 ftp、https 等 * user:pass@host.com:80 ===&gt; 存有该资源的主机IP地址（有时也包括端口号） * /path ===&gt; 主机资源的具体地址。如目录和文件名等。 */ URN : 永久统一资源定位符 在资源移动之后还能被找到 HTTP 报文请求行 声明 请求方法 、主机域名、资源路径 &amp; 协议版本 请求行的组成 = 请求方法 + 请求路径 + 协议版本 12GET /test/hi-there.txt HTTP/1.0// 请求行的组成 = 请求方法 + 请求路径 + 协议版本 请求头 声明 客户端、服务器 / 报文的部分信息 请求和响应报文的通用 Header 常见请求 Header 请求体 存放 需发送给服务器的数据信息 除此外还有响应报文，略 创建一个简单的 http 服务12345678const http = require('http')http .createServer(function(request, response) &#123; console.log('request come', request.url) response.end('123') &#125;) .listen(8888)]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] JavaScript深入之继承的多种方式和优缺点]]></title>
    <url>%2F2018%2F11%2F15%2Fjs-%E6%B7%B1%E5%85%A5%E4%B9%8B%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[写在前面本文讲解 JavaScript 各种继承方式和优缺点。 但是注意： 这篇文章更像是笔记，哎，再让我感叹一句：《JavaScript 高级程序设计》写得真是太好了！ 1.原型链继承123456789101112131415function Parent() &#123; this.name = 'kevin'&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child1 = new Child()console.log(child1.getName()) // kevin 问题： 1.引用类型的属性被所有实例共享，举个例子： 1234567891011121314151617function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123;&#125;Child.prototype = new Parent()var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // ["kevin", "daisy", "yayu"]var child2 = new Child()console.log(child2.names) // ["kevin", "daisy", "yayu"] 2.在创建 Child 的实例时，不能向 Parent 传参 2.借用构造函数(经典继承)1234567891011121314151617function Parent() &#123; this.names = ['kevin', 'daisy']&#125;function Child() &#123; Parent.call(this)&#125;var child1 = new Child()child1.names.push('yayu')console.log(child1.names) // ["kevin", "daisy", "yayu"]var child2 = new Child()console.log(child2.names) // ["kevin", "daisy"] 优点： 1.避免了引用类型的属性被所有实例共享 2.可以在 Child 中向 Parent 传参 举个例子： 123456789101112131415function Parent(name) &#123; this.name = name&#125;function Child(name) &#123; Parent.call(this, name)&#125;var child1 = new Child('kevin')console.log(child1.name) // kevinvar child2 = new Child('daisy')console.log(child2.name) // daisy 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法。 3.组合继承原型链继承和经典继承双剑合璧。 123456789101112131415161718192021222324252627282930function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()var child1 = new Child('kevin', '18')child1.colors.push('black')console.log(child1.name) // kevinconsole.log(child1.age) // 18console.log(child1.colors) // ["red", "blue", "green", "black"]var child2 = new Child('daisy', '20')console.log(child2.name) // daisyconsole.log(child2.age) // 20console.log(child2.colors) // ["red", "blue", "green"] 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 4.原型式继承12345function createObj(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125; 就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 缺点： 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 12345678910111213var person = &#123; name: 'kevin', friends: ['daisy', 'kelly']&#125;var person1 = createObj(person)var person2 = createObj(person)person1.name = 'person1'console.log(person2.name) // kevinperson1.firends.push('taylor')console.log(person2.friends) // ["daisy", "kelly", "taylor"] 注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = &#39;person1&#39;，给person1添加了 name 值，并非修改了原型上的 name 值。 5. 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = object.create(o) clone.sayName = function() &#123; console.log('hi') &#125; return clone&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 6. 寄生组合式继承为了方便大家阅读，在这里重复一下组合继承的代码： 12345678910111213141516171819function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;Child.prototype = new Parent()var child1 = new Child('kevin', '18')console.log(child1) 组合继承最大的缺点是会调用两次父构造函数。 一次是设置子类型实例的原型的时候： 1Child.prototype = new Parent() 一次在创建子类型实例的时候： 1var child1 = new Child('kevin', '18') 回想下 new 的模拟实现，其实在这句中，我们会执行： 1Parent.call(this, name) 在这里，我们又会调用了一次 Parent 构造函数。 所以，在这个例子中，如果我们打印 child1 对象，我们会发现 Child.prototype 和 child1 都有一个属性为colors，属性值为[&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]。 那么我们该如何精益求精，避免这一次重复调用呢？ 如果我们不使用 Child.prototype = new Parent() ，而是间接的让 Child.prototype 访问到 Parent.prototype 呢？ 看看如何实现： 123456789101112131415161718192021222324function Parent(name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;Parent.prototype.getName = function() &#123; console.log(this.name)&#125;function Child(name, age) &#123; Parent.call(this, name) this.age = age&#125;// 关键的三步var F = function() &#123;&#125;F.prototype = Parent.prototypeChild.prototype = new F()var child1 = new Child('kevin', '18')console.log(child1) 最后我们封装一下这个继承方法： 1234567891011121314function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype) prototype.constructor = child child.prototype = prototype&#125;// 当我们使用的时候：prototype(Child, Parent) 引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 相关链接 《JavaScript 深入之从原型到原型链》 《JavaScript 深入之 call 和 apply 的模拟实现》 《JavaScript 深入之 new 的模拟实现》 《JavaScript 深入之创建对象》 深入系列JavaScript 深入系列目录地址：https://github.com/mqyqingfeng/Blog。 JavaScript 深入系列预计写十五篇左右，旨在帮大家捋顺 JavaScript 底层知识，重点讲解如原型、作用域、执行上下文、变量对象、this、闭包、按值传递、call、apply、bind、new、继承等难点概念。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Javascript 深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] JavaScript深入之闭包]]></title>
    <url>%2F2018%2F11%2F15%2Fjs-%E6%B7%B1%E5%85%A5%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[定义MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 举个例子： 1234567var a = 1function foo() &#123; console.log(a)&#125;foo() foo 函数可以访问变量 a，但是 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量。 那么，函数 foo + foo 函数访问的自由变量 a 不就是构成了一个闭包嘛…… 还真是这样的！ 所以在《JavaScript 权威指南》中就讲到：从技术的角度讲，所有的 JavaScript 函数都是闭包。 咦，这怎么跟我们平时看到的讲到的闭包不一样呢！？ 别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义： ECMAScript 中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 接下来就来讲讲实践上的闭包。 分析让我们先写个例子，例子依然是来自《JavaScript 权威指南》，稍微做点改动： 1234567891011var scope = 'global scope'function checkscope() &#123; var scope = 'local scope' function f() &#123; return scope &#125; return f&#125;var foo = checkscope()foo() 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。 另一个与这段代码相似的例子，在《JavaScript 深入之执行上下文》中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this 等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this 等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。(这段我问的 PHP 同事……) 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO]&#125; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript 权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 必刷题接下来，看这道刷题必刷，面试必考的闭包题： 1234567891011var data = []for (var i = 0; i &lt; 3; i++) &#123; data[i] = function() &#123; console.log(i) &#125;&#125;data[0]()data[1]()data[2]() 答案是都是 3，让我们分析一下原因： 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 当执行 data[0] 函数的时候，data[0] 函数的作用域链为： 123data[0]Context = &#123; Scope: [AO, globalContext.VO]&#125; data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。 data[1] 和 data[2] 是一样的道理。 所以让我们改成闭包看看： 12345678910111213var data = []for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function(i) &#123; return function() &#123; console.log(i) &#125; &#125;)(i)&#125;data[0]()data[1]()data[2]() 当执行到 data[0] 函数之前，此时全局上下文的 VO 为： 123456globalContext = &#123; VO: &#123; data: [...], i: 3 &#125;&#125; 跟没改之前一模一样。 当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变： 123data[0]Context = &#123; Scope: [AO, 匿名函数Context.AO globalContext.VO]&#125; 匿名函数执行上下文的 AO 为： 123456789匿名函数Context = &#123; AO: &#123; arguments: &#123; 0: 0, length: 1 &#125;, i: 0 &#125;&#125; data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为 3)，所以打印的结果就是 0。 data[1] 和 data[2] 是一样的道理。 下一篇文章JavaScript 深入之参数按值传递 相关链接如果想了解执行上下文的具体变化，不妨循序渐进，阅读这六篇： 《JavaScript 深入之词法作用域和动态作用域》 《JavaScript 深入之执行上下文栈》 《JavaScript 深入之变量对象》 《JavaScript 深入之作用域链》 《JavaScript 深入之从 ECMAScript 规范解读 this》 《JavaScript 深入之执行上下文》]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Javascript 深入系列</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex 布局]]></title>
    <url>%2F2018%2F07%2F11%2Fcss-flex%2F</url>
    <content type="text"><![CDATA[Flex 基本概念 Flex 容器相关属性123.container&#123; display: flex | inline-flex; //可以有两种取值&#125; 需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。有下面六种属性可以设置在容器上，它们分别是： flex-direction 功能：决定水平方向的排列方向 参数：row | row-reverse | column | column-reverse flex-wrap 功能：决定容器内项目是否可以换行 参数：nowrap | wrap | wrap-reverse flex-flow 功能：flex-direction、flex-wrap 的简写形式 —&gt; 没什么卵用 参数：&lt;flex-direction&gt; | &lt;flex-wrap&gt; justify-content 功能：定义在水平方向的对齐方式 参数：flex-start | flex-end | center | space-between | space-around align-items 功能：定义了容器内项目的对齐方式 参数：stretch | flex-start | flex-end | center | baseline align-content 功能：定义了多根轴线的对齐方式，如果项目只有一根轴线，则该属性将不起作用 参数：stretch | flex-start | flex-end | center | space-between | space-around 说明 ：参数首位为默认值 ；参数中含有 reverse 的表示反方向 Justify-contentspace-between 两端对齐两端对齐，项目之间的间隔相等，即剩余空间等分成间隙 space-around 项目之间间隔相等每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 align-items建立在主轴为水平方向时测试，即 flex-direction: row ( 默认值 ) stretch 默认值 占满整个容器的高度即如果项目未设置高度或者设为 auto，将占满整个容器的高度。 假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。 flex-start 交叉轴的起点对齐假设容器高度设置为 100px，而项目分别为 20px, 40px, 60px, 80px, 100px, 则如下图显示 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 项目的第一行文字的基线对齐 Flex 项目属性 order 功能：定义项在容器中的排列顺序 参数：Number 即数字 flex-basis 参数: length | auto; flex-grow 功能：定义项目的放大比例 参数：Number flex-shrink 功能：定义了项目的缩小比例 参数：Number flex 功能：flex-grow, flex-shrink 和 flex-basis的简写 none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] align-self 功能：允许单个项目有与其他项目不一样的对齐方式 auto | flex-start | flex-end | center | baseline | stretch order 定义项目在容器中的排列顺序定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0在 HTML 结构中，虽然 -2，-1 的 item 排在后面，但是由于分别设置了 order，使之能够排到最前面。 flex-basis 算主轴是否有多余空间定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间 当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。 flex-grow 定义项目的放大比例默认值为 0，即如果存在剩余空间，也不放大 当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。 flex-shrink 定义了项目的缩小比例默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。 这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。 同理可得： 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小 flex flex-grow, flex-shrink 和 flex-basis的简写flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。同理，如下是等同的：123456.item &#123;flex: 2333 3222 234px;&#125;.item &#123; flex-grow: 2333; flex-shrink: 3222; flex-basis: 234px;&#125; 当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的：123456.item &#123;flex: none;&#125;.item &#123; flex-grow: 0; flex-shrink: 0; flex-basis: auto;&#125; 当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的：123456.item &#123;flex: auto;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: auto;&#125; 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的： flex:1相当于width:100%，就是撑开123456.item &#123;flex: 1;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; align-self: 允许单个项目有与其他项目不一样的对齐方式]]></content>
      <categories>
        <category>HTML-CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>flex</tag>
      </tags>
  </entry>
</search>
